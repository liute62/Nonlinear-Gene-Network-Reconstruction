source('~/simu/simu.R')
source('~/Documents/2015/Bioinfomatics/Process/Example.R')
source('~/Documents/2015/Bioinfomatics/Process/Example.R')
library(nlnet3)
setwd("/Users/liuhaodong1/simu")
source("clusGap.R")
source("DCOL_Kmeans.R")
############# the function to conduct simulation for one scenario
# epsilon: noise level
# n.depend: data generation dependence structure. can be 0, 1, 2
# n.samples: the number of columns of the matrix
# n.grps: the number of hidden clusters
# aver.grp.size: averge number of genes in a cluster
# n.fun.types: number of function types to use
# total.n: number of simulations
# min.size.ratio: to be passed to the dynamic tree cutting
one.simu<-function(module.size, epsilon, n.depend, n.samples=100, n.grps=10, aver.grp.size=100, n.fun.types=4, total.n=20, min.size.ratio)
{
library(nlnet3)
r<-rep(0,4)
for(N in 1:total.n)
{
n.genes<- (1+n.grps) * aver.grp.size
dataset=data.gen(n.genes, n.samples, n.grps, aver.grp.size, n.fun.types, epsilon, n.depend)
if (0 %in% unique(dataset$grps))
{
ngrp = length(unique(dataset$grps))-1
}
else
{
ngrp = length(unique(dataset$grps))
}
#print(dataset)
results<-data.cluster.2(dataset$data, ngrp, 100)$cluster
#print(results)
nlnet.mul<-nlnet(min.module.size=module.size,dataset$data,gene.community.method="multilevel",plot.method="none",gene.fdr.cutoff=0.1)$membership
print(nlnet.mul)
print(table(nlnet.mul))
nlnet.label<-nlnet(min.module.size=module.size,dataset$data,gene.community.method="label.propagation",plot.method="none",gene.fdr.cutoff=0.1)$membership
print(nlnet.label)
print(table(nlnet.label))
nlnet.leading<-nlnet(min.module.size=module.size,dataset$data,gene.community.method="leading.eigenvector",plot.method="none",gene.fdr.cutoff=0.1)$membership
print(nlnet.leading)
print(table(nlnet.leading))
processable<-"haha"
hc= nlhc(dataset$data)
hgrps<-cutreeDynamic(hc, minClusterSize= aver.grp.size*min.size.ratio)
processable<-try(hgrps2<-cutree(hc, h=-2))
#print(results)
#table(results)
#print(hgrps)
#table(hrgps)
#print(hgrps2)
#print(adjustedRandIndex(dataset$grps + 1, hgrps))
#print(adjustedRandIndex(dataset$grps + 1, hgrps2))
if(substr(processable,1,5)=="Error")
{
r<-rbind(r,c(
adjustedRandIndex(dataset$grps +1 , results+1),
adjustedRandIndex(dataset$grps + 1, hgrps),
NA,
adjustedRandIndex(dataset$grps +1 , nlnet.mul),
adjustedRandIndex(dataset$grps +1 , nlnet.label),
adjustedRandIndex(dataset$grps +1 , nlnet.leading)))
}else{
r<-rbind(r,c(
adjustedRandIndex(dataset$grps +1 , results+1),
adjustedRandIndex(dataset$grps + 1, hgrps),
adjustedRandIndex(dataset$grps + 1, hgrps2),
adjustedRandIndex(dataset$grps +1 , nlnet.mul),
adjustedRandIndex(dataset$grps +1 , nlnet.label),
adjustedRandIndex(dataset$grps +1 , nlnet.leading)))
}
}
print("end")
r<-r[-1,]
r
}
############# actual simulation
#all.epsilon<-c(1.2, 1.6, 2)
#all.n.depend<-c(0,1,2)
#all.grp.size<-c(100)
#min.size.ratio<-c(0.5, 0.7, 0.9, 1)
#n.grps<-c(10, 20)
all.module.size<-c(5,10)
all.epsilon<-c(0.5)
all.n.depend<-0
all.grp.size<-100
min.size.ratio<-1
n.grps<-10
combos<-expand.grid(all.epsilon, all.n.depend,all.grp.size,min.size.ratio, n.grps,all.module.size)
#combos
#foreach(m=nrow(combos):1) %dopar%
for(m in 1:nrow(combos))
{
#rec<-one.simu(epsilon=epsilon, n.depend=n.depend, aver.grp.size=grp.size, min.size.ratio=min.size.ratio, n.grps=n.grps, n.fun.types=4, total.n=2)
rec<-one.simu(module.size=combos[m,6],epsilon=combos[m,1], n.depend=combos[m,2], aver.grp.size=combos[m,3], min.size.ratio=combos[m,4], n.grps=combos[m,5], n.fun.types=4, total.n=1)
print(rec)
#save(rec, file=paste("simu epsilon",epsilon, "n.depend", n.depend, "grp size",grp.size, "min size ratio",min.size.ratio," n grps",n.grps,".bin"))
save(rec, file=paste("simu epsilon", combos[m,1], "n.depend", combos[m,2],"grp size",combos[m,3], "min size ratio", combos[m,4], "n grps", combos[m,5], ".bin"))
}
#}
############# plotting results
par(mfcol=c(2,3))
for(grp.size in c(100))
{
#for(n.depend in c(0,1,2))
for(n.depend in c(0))
{
#for(n.grps in c(10, 20))
for(n.grps in c(10))
{
r<-rep(NA,8)
#for(epsilon in c(0.2, 0.6, 0.8, 1.2, 1.6))
for(epsilon in c(0.5,1.0))
{
#for(min.size.ratio in c(0.5, 0.7, 0.9, 1))
for(min.size.ratio in c(1))
{
#this.name<-paste("linear simu epsilon", epsilon, "n.depend", n.depend,"grp size",grp.size, "min size ratio", min.size.ratio, "n grps", n.grps, ".bin")
this.name<-paste("simu epsilon",epsilon, "n.depend", n.depend, "grp size",grp.size, "min size ratio",min.size.ratio,"n grps", n.grps,".bin")
load(this.name)
#load("simu epsilon 1.2 n.depend 2 grp size 10 min size ratio 1 n grps 20.bin")
if(epsilon == 0.5){
this<-apply(rec,2,mean)[c(1,4,2)]
}else{
this<-c(this, apply(rec,2,mean)[2])
}
}
r<-rbind(r, c(epsilon, this, apply(rec,2,mean)[3]))
}
r<-r[-1,]
r
plot(r[,1], r[,2], xlab="noise SD/signal SD", ylab="adjusted Rand Index", type="l", col="red",ylim=c(0,1),lwd=2, main=paste("# clusters", n.grps,", n.depend", n.depend))
lines(r[,1], r[,3],col="green",lwd=2, lty=1)
lines(r[,1], r[,4],col="blue",lwd=2, lty=1)
lines(r[,1], r[,5],col="blue",lwd=2, lty=2)
lines(r[,1], r[,6],col="blue",lwd=2, lty=3)
lines(r[,1], r[,7],col="blue",lwd=2, lty=4)
lines(r[,1], r[,8],col="cyan",lwd=2, lty=1)
lines(r[,1], r[,9],col="yellow",lwd=2,lty=1)
}
}
}
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/Documents/2015/Bioinfomatics/Process/Example.R')
source('~/Documents/2015/Bioinfomatics/Process/Example.R')
source('~/Documents/2015/Bioinfomatics/Process/Example.R')
source('~/Documents/2015/Bioinfomatics/Process/Example.R')
source('~/Documents/2015/Bioinfomatics/Process/Example.R')
source('~/Documents/2015/Bioinfomatics/Process/Example.R')
library(nlnet3)
setwd("/Users/liuhaodong1/simu")
source("clusGap.R")
source("DCOL_Kmeans.R")
# n.depend: data generation dependence structure. can be 0, 1, 2
# n.grps: the number of hidden clusters
# n.fun.types: number of function types to use
# min.size.ratio: to be passed to the dynamic tree cutting
{
print(cutoff.quantile)
for(N in 1:total.n)
n.genes<- (1+n.grps) * aver.grp.size
if (0 %in% unique(dataset$grps))
ngrp = length(unique(dataset$grps))-1
else
ngrp = length(unique(dataset$grps))
#print(dataset)
#print(results)
# epsilon: noise level
# aver.grp.size: averge number of genes in a cluster
one.simu<-function(cutoff.quantile,module.size, epsilon, n.depend, n.samples=100, n.grps=10, aver.grp.size=100, n.fun.types=4, total.n=20, min.size.ratio)
nlnet.mul<-nlnet(min.module.size=module.size,dataset$data,gene.community.method="multilevel",plot.method="false",fdr.quantile=cutoff.quantile)$membership
{
}
{
############# the function to conduct simulation for one scenario
# total.n: number of simulations
r<-rep(0,4)
dataset=data.gen(n.genes, n.samples, n.grps, aver.grp.size, n.fun.types, epsilon, n.depend)
print(nlnet.mul)
# n.samples: the number of columns of the matrix
{
results<-data.cluster.2(dataset$data, ngrp, 100)$cluster
}
library(nlnet3)
print(table(nlnet.mul))
nlnet.label<-nlnet(min.module.size=module.size,dataset$data,gene.community.method="label.propagation",plot.method="false",fdr.quantile=cutoff.quantile)$membership
print(nlnet.label)
print(table(nlnet.label))
nlnet.leading<-nlnet(min.module.size=module.size,dataset$data,gene.community.method="leading.eigenvector",plot.method="false",fdr.quantile=cutoff.quantile)$membership
print(nlnet.leading)
print(table(nlnet.leading))
processable<-"haha"
hc= nlhc(dataset$data)
hgrps<-cutreeDynamic(hc, minClusterSize= aver.grp.size*min.size.ratio)
processable<-try(hgrps2<-cutree(hc, h=-2))
#print(results)
#table(results)
#print(hgrps)
#table(hrgps)
#print(hgrps2)
#print(adjustedRandIndex(dataset$grps + 1, hgrps))
#print(adjustedRandIndex(dataset$grps + 1, hgrps2))
if(substr(processable,1,5)=="Error")
{
r<-rbind(r,c(
adjustedRandIndex(dataset$grps +1 , results+1),
adjustedRandIndex(dataset$grps + 1, hgrps),
NA,
adjustedRandIndex(dataset$grps +1 , nlnet.mul),
adjustedRandIndex(dataset$grps +1 , nlnet.label),
adjustedRandIndex(dataset$grps +1 , nlnet.leading)))
}else{
r<-rbind(r,c(
adjustedRandIndex(dataset$grps +1 , results+1),
adjustedRandIndex(dataset$grps + 1, hgrps),
adjustedRandIndex(dataset$grps + 1, hgrps2),
adjustedRandIndex(dataset$grps +1 , nlnet.mul),
adjustedRandIndex(dataset$grps +1 , nlnet.label),
adjustedRandIndex(dataset$grps +1 , nlnet.leading)))
}
}
print("end")
r<-r[-1,]
r
}
############# actual simulation
#all.epsilon<-c(1.2, 1.6, 2)
#all.n.depend<-c(0,1,2)
#all.grp.size<-c(100)
#min.size.ratio<-c(0.5, 0.7, 0.9, 1)
#n.grps<-c(10, 20)
all.module.size<-c(1)
#all.epsilon<-c(0.2, 0.6, 0.8, 1.2, 1.6)
all.epsilon<-c(0.2)
all.n.depend<-0
all.grp.size<-100
min.size.ratio<-1
n.grps<-10
combos<-expand.grid(all.epsilon, all.n.depend,all.grp.size,min.size.ratio, n.grps,all.module.size)
#combos
#foreach(m=nrow(combos):1) %dopar%
#cutoffs<-c(0.1,0.15,0.2,0.25,0.3)
for(m in 1:nrow(combos))
{
#rec<-one.simu(epsilon=epsilon, n.depend=n.depend, aver.grp.size=grp.size, min.size.ratio=min.size.ratio, n.grps=n.grps, n.fun.types=4, total.n=2)
rec<-one.simu(cutoff.quantile=0.0001,module.size=combos[m,6],epsilon=combos[m,1], n.depend=combos[m,2], aver.grp.size=combos[m,3], min.size.ratio=combos[m,4], n.grps=combos[m,5], n.fun.types=4, total.n=1)
print(rec)
#save(rec, file=paste("simu epsilon",epsilon, "n.depend", n.depend, "grp size",grp.size, "min size ratio",min.size.ratio," n grps",n.grps,".bin"))
save(rec, file=paste("simu epsilon", combos[m,1], "n.depend", combos[m,2],"grp size",combos[m,3], "min size ratio", combos[m,4], "n grps", combos[m,5], ".bin"))
}
# min.size.ratio: to be passed to the dynamic tree cutting
one.simu<-function(cutoff.quantile,module.size, epsilon, n.depend, n.samples=100, n.grps=10, aver.grp.size=100, n.fun.types=4, total.n=20, min.size.ratio)
{
library(nlnet3)
source('~/simu/simu.R')
print(cutoff.quantile)
r<-rep(0,4)
for(N in 1:total.n)
{
n.genes<- (1+n.grps) * aver.grp.size
dataset=data.gen(n.genes, n.samples, n.grps, aver.grp.size, n.fun.types, epsilon, n.depend)
if (0 %in% unique(dataset$grps))
{
ngrp = length(unique(dataset$grps))-1
}
else
{
ngrp = length(unique(dataset$grps))
}
#print(dataset)
results<-data.cluster.2(dataset$data, ngrp, 100)$cluster
#print(results)
nlnet.mul<-nlnet(min.module.size=module.size,dataset$data,gene.community.method="multilevel",plot.method="false",fdr.quantile=cutoff.quantile)$membership
print(nlnet.mul)
print(table(nlnet.mul))
nlnet.label<-nlnet(min.module.size=module.size,dataset$data,gene.community.method="label.propagation",plot.method="false",fdr.quantile=cutoff.quantile)$membership
print(nlnet.label)
print(table(nlnet.label))
nlnet.leading<-nlnet(min.module.size=module.size,dataset$data,gene.community.method="leading.eigenvector",plot.method="false",fdr.quantile=cutoff.quantile)$membership
print(nlnet.leading)
print(table(nlnet.leading))
processable<-"haha"
hc= nlhc(dataset$data)
hgrps<-cutreeDynamic(hc, minClusterSize= aver.grp.size*min.size.ratio)
processable<-try(hgrps2<-cutree(hc, h=-2))
#print(results)
#table(results)
#print(hgrps)
#table(hrgps)
#print(hgrps2)
#print(adjustedRandIndex(dataset$grps + 1, hgrps))
#print(adjustedRandIndex(dataset$grps + 1, hgrps2))
if(substr(processable,1,5)=="Error")
{
r<-rbind(r,c(
adjustedRandIndex(dataset$grps +1 , results+1),
adjustedRandIndex(dataset$grps + 1, hgrps),
NA,
adjustedRandIndex(dataset$grps +1 , nlnet.mul),
adjustedRandIndex(dataset$grps +1 , nlnet.label),
adjustedRandIndex(dataset$grps +1 , nlnet.leading)))
}else{
r<-rbind(r,c(
adjustedRandIndex(dataset$grps +1 , results+1),
adjustedRandIndex(dataset$grps + 1, hgrps),
adjustedRandIndex(dataset$grps + 1, hgrps2),
adjustedRandIndex(dataset$grps +1 , nlnet.mul),
adjustedRandIndex(dataset$grps +1 , nlnet.label),
adjustedRandIndex(dataset$grps +1 , nlnet.leading)))
}
}
print("end")
r<-r[-1,]
r
}
############# actual simulation
#all.epsilon<-c(1.2, 1.6, 2)
#all.n.depend<-c(0,1,2)
#all.grp.size<-c(100)
#min.size.ratio<-c(0.5, 0.7, 0.9, 1)
#n.grps<-c(10, 20)
all.module.size<-c(1)
#all.epsilon<-c(0.2, 0.6, 0.8, 1.2, 1.6)
all.epsilon<-c(0.2)
all.n.depend<-0
all.grp.size<-100
min.size.ratio<-1
n.grps<-10
combos<-expand.grid(all.epsilon, all.n.depend,all.grp.size,min.size.ratio, n.grps,all.module.size)
#combos
#foreach(m=nrow(combos):1) %dopar%
#cutoffs<-c(0.1,0.15,0.2,0.25,0.3)
for(m in 1:nrow(combos))
{
#rec<-one.simu(epsilon=epsilon, n.depend=n.depend, aver.grp.size=grp.size, min.size.ratio=min.size.ratio, n.grps=n.grps, n.fun.types=4, total.n=2)
rec<-one.simu(cutoff.quantile=0.0001,module.size=combos[m,6],epsilon=combos[m,1], n.depend=combos[m,2], aver.grp.size=combos[m,3], min.size.ratio=combos[m,4], n.grps=combos[m,5], n.fun.types=4, total.n=1)
print(rec)
#save(rec, file=paste("simu epsilon",epsilon, "n.depend", n.depend, "grp size",grp.size, "min size ratio",min.size.ratio," n grps",n.grps,".bin"))
save(rec, file=paste("simu epsilon", combos[m,1], "n.depend", combos[m,2],"grp size",combos[m,3], "min size ratio", combos[m,4], "n grps", combos[m,5], ".bin"))
}
library(nlnet3)
#cutoffs<-c(0.1,0.15,0.2,0.25,0.3)
{
rec<-one.simu(cutoff.quantile=0.0001,module.size=combos[m,6],epsilon=combos[m,1], n.depend=combos[m,2], aver.grp.size=combos[m,3], min.size.ratio=combos[m,4], n.grps=combos[m,5], n.fun.types=4, total.n=1)
#save(rec, file=paste("simu epsilon",epsilon, "n.depend", n.depend, "grp size",grp.size, "min size ratio",min.size.ratio," n grps",n.grps,".bin"))
}
library(nlnet3)
source('~/simu/simu.R')
source('~/simu/simu.R')
library(nlnet3)
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
View(combos)
source('~/simu/simu.R')
View(combos)
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
cutoff.tmp<-0
switch(combos[m,1],
all.epsilon[1] = cutoff.tmp<-all.fdr.quantile[1],
#rec<-one.simu(epsilon=epsilon, n.depend=n.depend, aver.grp.size=grp.size, min.size.ratio=min.size.ratio, n.grps=n.grps, n.fun.types=4, total.n=2)
cutoff.tmp<-0
switch(combos[m,1],
cutoff.tmp<-0
switch(combos[m,1],
all.epsilon[1] = cutoff.tmp<-all.fdr.quantile[1],
all.epsilon[2] = cutoff.tmp<-all.fdr.quantile[2],
all.epsilon[3] = cutoff.tmp<-all.fdr.quantile[3],
all.epsilon[4] = cutoff.tmp<-all.fdr.quantile[4],)
rec<-one.simu(cutoff.quantile=,module.size=combos[m,6],epsilon=combos[m,1], n.depend=combos[m,2], aver.grp.size=combos[m,3], min.size.ratio=combos[m,4], n.grps=combos[m,5], n.fun.types=4, total.n=20)
for(m in 1:nrow(combos))
{
#rec<-one.simu(epsilon=epsilon, n.depend=n.depend, aver.grp.size=grp.size, min.size.ratio=min.size.ratio, n.grps=n.grps, n.fun.types=4, total.n=2)
cutoff.tmp<-0
switch(combos[m,1],
all.epsilon[1] = cutoff.tmp<-all.fdr.quantile[1],
all.epsilon[2] = cutoff.tmp<-all.fdr.quantile[2],
all.epsilon[3] = cutoff.tmp<-all.fdr.quantile[3],
all.epsilon[4] = cutoff.tmp<-all.fdr.quantile[4],)
rec<-one.simu(cutoff.quantile=,module.size=combos[m,6],epsilon=combos[m,1], n.depend=combos[m,2], aver.grp.size=combos[m,3], min.size.ratio=combos[m,4], n.grps=combos[m,5], n.fun.types=4, total.n=20)
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
#foreach(m=nrow(combos):1) %dopar%
#cutoffs<-c(0.1,0.15,0.2,0.25,0.3)
for(m in 1:nrow(combos))
{
#rec<-one.simu(epsilon=epsilon, n.depend=n.depend, aver.grp.size=grp.size, min.size.ratio=min.size.ratio, n.grps=n.grps, n.fun.types=4, total.n=2)
cutoff.tmp<-0
cutoff.tmp<-switch(combos[m,1],
all.epsilon[1]<-all.fdr.quantile[1],
all.epsilon[2]<-all.fdr.quantile[2],
all.epsilon[3]<-all.fdr.quantile[3],
all.epsilon[4]<-all.fdr.quantile[4])
print(cutoff.tmp)
rec<-one.simu(cutoff.quantile=cutoff.tmp,module.size=combos[m,6],epsilon=combos[m,1], n.depend=combos[m,2], aver.grp.size=combos[m,3], min.size.ratio=combos[m,4], n.grps=combos[m,5], n.fun.types=4, total.n=20)
print(rec)
#save(rec, file=paste("simu epsilon",epsilon, "n.depend", n.depend, "grp size",grp.size, "min size ratio",min.size.ratio," n grps",n.grps,".bin"))
save(rec, file=paste("simu epsilon", combos[m,1], "n.depend", combos[m,2],"grp size",combos[m,3], "min size ratio", combos[m,4], "n grps", combos[m,5], ".bin"))
}
#foreach(m=nrow(combos):1) %dopar%
#cutoffs<-c(0.1,0.15,0.2,0.25,0.3)
for(m in 1:nrow(combos))
{
#rec<-one.simu(epsilon=epsilon, n.depend=n.depend, aver.grp.size=grp.size, min.size.ratio=min.size.ratio, n.grps=n.grps, n.fun.types=4, total.n=2)
cutoff.tmp<-0
cutoff.tmp<-switch(combos[m,1],
all.epsilon[1]<-all.fdr.quantile[1],
all.epsilon[2]<-all.fdr.quantile[2],
all.epsilon[3]<-all.fdr.quantile[3],
all.epsilon[4]<-all.fdr.quantile[4])
print(cutoff.tmp)
rec<-one.simu(cutoff.quantile=cutoff.tmp,module.size=combos[m,6],epsilon=combos[m,1], n.depend=combos[m,2], aver.grp.size=combos[m,3], min.size.ratio=combos[m,4], n.grps=combos[m,5], n.fun.types=4, total.n=20)
print(rec)
#save(rec, file=paste("simu epsilon",epsilon, "n.depend", n.depend, "grp size",grp.size, "min size ratio",min.size.ratio," n grps",n.grps,".bin"))
save(rec, file=paste("simu epsilon", combos[m,1], "n.depend", combos[m,2],"grp size",combos[m,3], "min size ratio", combos[m,4], "n grps", combos[m,5], ".bin"))
}
View(combos)
source('~/simu/simu.R')
switch()
switch
help(switch)
source('~/simu/simu.R')
require(stats)
centre <- function(x, type) {
switch(type,
mean = mean(x),
median = median(x),
trimmed = mean(x, trim = .1))
}
centre(x, "median")
x <- rcauchy(10)
centre(x, "mean")
centre(x, "median")
centre(x, "trimmed")
ccc <- c("b","QQ","a","A","bb")
# note: cat() produces no output for NULL
for(ch in ccc)
cat(ch,":", switch(EXPR = ch, a = 1, b = 2:3), "\n")
for(ch in ccc)
cat(ch,":", switch(EXPR = ch, a =, A = 1, b = 2:3, "Otherwise: last"),"\n")
#rec<-one.simu(epsilon=epsilon, n.depend=n.depend, aver.grp.size=grp.size, min.size.ratio=min.size.ratio, n.grps=n.grps, n.fun.types=4, total.n=2)
cutoff.tmp<-0
print(combos[m,1])
cutoff.tmp<-switch(combos[m,1],
0.2 = all.epsilon[1]<-all.fdr.quantile[1],
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
source('~/simu/simu.R')
library(nlnet3)
source('~/simu/simu.R')
View(combos)
